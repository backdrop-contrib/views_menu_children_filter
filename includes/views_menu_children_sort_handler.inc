<?php

class views_menu_children_sort_handler extends  \views_handler_sort {

  function set_definition($definition) {
    $this->table_alias = 'menu_links';
    parent::set_definition(array('field' => 'weight'));
  }

  function option_definition() {
    $options = parent::option_definition();
    $options['target_menu'] = array(
      'default' => ''
    );

    return $options;
  }

  function can_expose() {
    return false;
  }

  function options_submit(&$form, &$form_state) {
    // If the target_menu form field is disabled, that mean we need to use the argument handler's value.
    if(isset($form['target_menu']['#attributes']['disabled'])) {
      $form_state['values']['target_menu'] = $this->hasAttachedContextFilter();
    }
    parent::options_submit($form, $form_state); // TODO: Change the autogenerated stub
  }

  function query() {
    // figure out if the needed join is already applied via the potential existence of the views_menu_children_filter.
    $target_menu = $this->hasAttachedContextFilter();
    if(empty($target_menu)) {
      $target_menu = $this->options['target_menu'];
    }

    \views_menu_children_argument::joinMenuLinksTableToNode($this->query, $target_menu);
    $this->ensure_my_table();
    // Add the field.
    $this->query->add_orderby($this->table_alias, $this->real_field, $this->options['order']);
    $this->query->add_orderby($this->table_alias, 'link_title', $this->options['order']);
    $this->query->add_orderby($this->table_alias, 'mlid', $this->options['order']);
  }

  function pre_query() {
    parent::pre_query(); // TODO: Change the autogenerated stub
  }

  function ui_name($short = FALSE) {
    return t('Content: Menu children');
  }

  function options_form(&$form, &$form_state) {
    parent::options_form($form, $form_state); // TODO: Change the autogenerated stub

    $conflicting_selected_menu = $this->hasAttachedContextFilter();

    $default_value = !$conflicting_selected_menu
      ? $this->options['target_menu']
      : $conflicting_selected_menu;

    \views_menu_children_argument::buildMenuSelectForm($form, $form_state, ($default_value . ''));

    // If there is a conflicting menu selected in the argument handler, disable
    // the select box here and tell the user they can't change the selection.
    if(!empty($conflicting_selected_menu)) {
      $form['target_menu']['#attributes']['disabled'] = 'disabled';
      $form['target_menu']['#description'] =
        t("This option is locked because you have a \"Menu children\" contextual filter already configured for this view.
<br />When a Menu Children context filter and Menu Children sort are applied to the same view, they must use the same target menu.
<br/>To change the target menu, make the change to the contextual filter.");

    }
  }


  /**
   * Detects whether there is an attached views_menu_children_argument handler
   * attached as a context filter.
   *
   * If there is one, we'll use the selected target menu from that
   * setting to avoid conflict as we'd normally be performing the same join.
   * @return string|null Returns the selected menu already attached to
   * the query as a join.
   * If none, returns null.
   */
  private function hasAttachedContextFilter() {
    $filters = $this->view->display_handler->get_option('arguments');
    if(isset($filters['menu_children_filter'])) {
      return $filters['menu_children_filter']['target_menu'];
    }
    return null;
  }
}
